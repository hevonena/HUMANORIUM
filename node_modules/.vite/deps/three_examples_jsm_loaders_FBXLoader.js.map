{
  "version": 3,
  "sources": ["../../three/examples/jsm/curves/NURBSUtils.js", "../../three/examples/jsm/curves/NURBSCurve.js", "../../three/examples/jsm/loaders/FBXLoader.js"],
  "sourcesContent": ["import {\n\tVector3,\n\tVector4\n} from 'three';\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\nFinds knot vector span.\n\np : degree\nu : parametric value\nU : knot vector\n\nreturns the span\n*/\nfunction findSpan( p, u, U ) {\n\n\tconst n = U.length - p - 1;\n\n\tif ( u >= U[ n ] ) {\n\n\t\treturn n - 1;\n\n\t}\n\n\tif ( u <= U[ p ] ) {\n\n\t\treturn p;\n\n\t}\n\n\tlet low = p;\n\tlet high = n;\n\tlet mid = Math.floor( ( low + high ) / 2 );\n\n\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\tif ( u < U[ mid ] ) {\n\n\t\t\thigh = mid;\n\n\t\t} else {\n\n\t\t\tlow = mid;\n\n\t\t}\n\n\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t}\n\n\treturn mid;\n\n}\n\n\n/*\nCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nU    : knot vector\n\nreturns array[p+1] with basis functions values.\n*/\nfunction calcBasisFunctions( span, u, p, U ) {\n\n\tconst N = [];\n\tconst left = [];\n\tconst right = [];\n\tN[ 0 ] = 1.0;\n\n\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\tright[ j ] = U[ span + j ] - u;\n\n\t\tlet saved = 0.0;\n\n\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\tconst rv = right[ r + 1 ];\n\t\t\tconst lv = left[ j - r ];\n\t\t\tconst temp = N[ r ] / ( rv + lv );\n\t\t\tN[ r ] = saved + rv * temp;\n\t\t\tsaved = lv * temp;\n\n\t\t}\n\n\t\tN[ j ] = saved;\n\n\t}\n\n\treturn N;\n\n}\n\n\n/*\nCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\np : degree of B-Spline\nU : knot vector\nP : control points (x, y, z, w)\nu : parametric point\n\nreturns point for given u\n*/\nfunction calcBSplinePoint( p, U, P, u ) {\n\n\tconst span = findSpan( p, u, U );\n\tconst N = calcBasisFunctions( span, u, p, U );\n\tconst C = new Vector4( 0, 0, 0, 0 );\n\n\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\tconst point = P[ span - p + j ];\n\t\tconst Nj = N[ j ];\n\t\tconst wNj = point.w * Nj;\n\t\tC.x += point.x * wNj;\n\t\tC.y += point.y * wNj;\n\t\tC.z += point.z * wNj;\n\t\tC.w += point.w * Nj;\n\n\t}\n\n\treturn C;\n\n}\n\n\n/*\nCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\nspan : span in which u lies\nu    : parametric point\np    : degree\nn    : number of derivatives to calculate\nU    : knot vector\n\nreturns array[n+1][p+1] with basis functions derivatives\n*/\nfunction calcBasisFunctionDerivatives( span, u, p, n, U ) {\n\n\tconst zeroArr = [];\n\tfor ( let i = 0; i <= p; ++ i )\n\t\tzeroArr[ i ] = 0.0;\n\n\tconst ders = [];\n\n\tfor ( let i = 0; i <= n; ++ i )\n\t\tders[ i ] = zeroArr.slice( 0 );\n\n\tconst ndu = [];\n\n\tfor ( let i = 0; i <= p; ++ i )\n\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\tndu[ 0 ][ 0 ] = 1.0;\n\n\tconst left = zeroArr.slice( 0 );\n\tconst right = zeroArr.slice( 0 );\n\n\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\tright[ j ] = U[ span + j ] - u;\n\n\t\tlet saved = 0.0;\n\n\t\tfor ( let r = 0; r < j; ++ r ) {\n\n\t\t\tconst rv = right[ r + 1 ];\n\t\t\tconst lv = left[ j - r ];\n\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\tconst temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\tsaved = lv * temp;\n\n\t\t}\n\n\t\tndu[ j ][ j ] = saved;\n\n\t}\n\n\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t}\n\n\tfor ( let r = 0; r <= p; ++ r ) {\n\n\t\tlet s1 = 0;\n\t\tlet s2 = 1;\n\n\t\tconst a = [];\n\t\tfor ( let i = 0; i <= p; ++ i ) {\n\n\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t}\n\n\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\t\tlet d = 0.0;\n\t\t\tconst rk = r - k;\n\t\t\tconst pk = p - k;\n\n\t\t\tif ( r >= k ) {\n\n\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t}\n\n\t\t\tconst j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\tconst j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\tfor ( let j = j1; j <= j2; ++ j ) {\n\n\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t}\n\n\t\t\tif ( r <= pk ) {\n\n\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t}\n\n\t\t\tders[ k ][ r ] = d;\n\n\t\t\tconst j = s1;\n\t\t\ts1 = s2;\n\t\t\ts2 = j;\n\n\t\t}\n\n\t}\n\n\tlet r = p;\n\n\tfor ( let k = 1; k <= n; ++ k ) {\n\n\t\tfor ( let j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ k ][ j ] *= r;\n\n\t\t}\n\n\t\tr *= p - k;\n\n\t}\n\n\treturn ders;\n\n}\n\n\n/*\n\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points\n\tu  : Parametric points\n\tnd : number of derivatives\n\n\treturns array[d+1] with derivatives\n\t*/\nfunction calcBSplineDerivatives( p, U, P, u, nd ) {\n\n\tconst du = nd < p ? nd : p;\n\tconst CK = [];\n\tconst span = findSpan( p, u, U );\n\tconst nders = calcBasisFunctionDerivatives( span, u, p, du, U );\n\tconst Pw = [];\n\n\tfor ( let i = 0; i < P.length; ++ i ) {\n\n\t\tconst point = P[ i ].clone();\n\t\tconst w = point.w;\n\n\t\tpoint.x *= w;\n\t\tpoint.y *= w;\n\t\tpoint.z *= w;\n\n\t\tPw[ i ] = point;\n\n\t}\n\n\tfor ( let k = 0; k <= du; ++ k ) {\n\n\t\tconst point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\tfor ( let j = 1; j <= p; ++ j ) {\n\n\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t}\n\n\t\tCK[ k ] = point;\n\n\t}\n\n\tfor ( let k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\tCK[ k ] = new Vector4( 0, 0, 0 );\n\n\t}\n\n\treturn CK;\n\n}\n\n\n/*\nCalculate \"K over I\"\n\nreturns k!/(i!(k-i)!)\n*/\nfunction calcKoverI( k, i ) {\n\n\tlet nom = 1;\n\n\tfor ( let j = 2; j <= k; ++ j ) {\n\n\t\tnom *= j;\n\n\t}\n\n\tlet denom = 1;\n\n\tfor ( let j = 2; j <= i; ++ j ) {\n\n\t\tdenom *= j;\n\n\t}\n\n\tfor ( let j = 2; j <= k - i; ++ j ) {\n\n\t\tdenom *= j;\n\n\t}\n\n\treturn nom / denom;\n\n}\n\n\n/*\nCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\nPders : result of function calcBSplineDerivatives\n\nreturns array with derivatives for rational curve.\n*/\nfunction calcRationalCurveDerivatives( Pders ) {\n\n\tconst nd = Pders.length;\n\tconst Aders = [];\n\tconst wders = [];\n\n\tfor ( let i = 0; i < nd; ++ i ) {\n\n\t\tconst point = Pders[ i ];\n\t\tAders[ i ] = new Vector3( point.x, point.y, point.z );\n\t\twders[ i ] = point.w;\n\n\t}\n\n\tconst CK = [];\n\n\tfor ( let k = 0; k < nd; ++ k ) {\n\n\t\tconst v = Aders[ k ].clone();\n\n\t\tfor ( let i = 1; i <= k; ++ i ) {\n\n\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t}\n\n\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t}\n\n\treturn CK;\n\n}\n\n\n/*\nCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\np  : degree\nU  : knot vector\nP  : control points in homogeneous space\nu  : parametric points\nnd : number of derivatives\n\nreturns array with derivatives.\n*/\nfunction calcNURBSDerivatives( p, U, P, u, nd ) {\n\n\tconst Pders = calcBSplineDerivatives( p, U, P, u, nd );\n\treturn calcRationalCurveDerivatives( Pders );\n\n}\n\n\n/*\nCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\np, q : degrees of B-Spline surface\nU, V : knot vectors\nP    : control points (x, y, z, w)\nu, v : parametric values\n\nreturns point for given (u, v)\n*/\nfunction calcSurfacePoint( p, q, U, V, P, u, v, target ) {\n\n\tconst uspan = findSpan( p, u, U );\n\tconst vspan = findSpan( q, v, V );\n\tconst Nu = calcBasisFunctions( uspan, u, p, U );\n\tconst Nv = calcBasisFunctions( vspan, v, q, V );\n\tconst temp = [];\n\n\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\ttemp[ l ] = new Vector4( 0, 0, 0, 0 );\n\t\tfor ( let k = 0; k <= p; ++ k ) {\n\n\t\t\tconst point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\tconst w = point.w;\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t}\n\n\t}\n\n\tconst Sw = new Vector4( 0, 0, 0, 0 );\n\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t}\n\n\tSw.divideScalar( Sw.w );\n\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n}\n\n/*\nCalculate rational B-Spline volume point. See The NURBS Book, page 134, algorithm A4.3.\n\np, q, r   : degrees of B-Splinevolume\nU, V, W   : knot vectors\nP         : control points (x, y, z, w)\nu, v, w   : parametric values\n\nreturns point for given (u, v, w)\n*/\nfunction calcVolumePoint( p, q, r, U, V, W, P, u, v, w, target ) {\n\n\tconst uspan = findSpan( p, u, U );\n\tconst vspan = findSpan( q, v, V );\n\tconst wspan = findSpan( r, w, W );\n\tconst Nu = calcBasisFunctions( uspan, u, p, U );\n\tconst Nv = calcBasisFunctions( vspan, v, q, V );\n\tconst Nw = calcBasisFunctions( wspan, w, r, W );\n\tconst temp = [];\n\n\tfor ( let m = 0; m <= r; ++ m ) {\n\n\t\ttemp[ m ] = [];\n\n\t\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\t\ttemp[ m ][ l ] = new Vector4( 0, 0, 0, 0 );\n\t\t\tfor ( let k = 0; k <= p; ++ k ) {\n\n\t\t\t\tconst point = P[ uspan - p + k ][ vspan - q + l ][ wspan - r + m ].clone();\n\t\t\t\tconst w = point.w;\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\t\t\t\ttemp[ m ][ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\tconst Sw = new Vector4( 0, 0, 0, 0 );\n\tfor ( let m = 0; m <= r; ++ m ) {\n\t\tfor ( let l = 0; l <= q; ++ l ) {\n\n\t\t\tSw.add( temp[ m ][ l ].multiplyScalar( Nw[ m ] ).multiplyScalar( Nv[ l ] ) );\n\n\t\t}\n\t}\n\n\tSw.divideScalar( Sw.w );\n\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n}\n\n\nexport {\n\tfindSpan,\n\tcalcBasisFunctions,\n\tcalcBSplinePoint,\n\tcalcBasisFunctionDerivatives,\n\tcalcBSplineDerivatives,\n\tcalcKoverI,\n\tcalcRationalCurveDerivatives,\n\tcalcNURBSDerivatives,\n\tcalcSurfacePoint,\n\tcalcVolumePoint,\n};\n", "import {\n\tCurve,\n\tVector3,\n\tVector4\n} from 'three';\nimport * as NURBSUtils from '../curves/NURBSUtils.js';\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nclass NURBSCurve extends Curve {\n\n\tconstructor(\n\t\tdegree,\n\t\tknots /* array of reals */,\n\t\tcontrolPoints /* array of Vector(2|3|4) */,\n\t\tstartKnot /* index in knots */,\n\t\tendKnot /* index in knots */\n\t) {\n\n\t\tsuper();\n\n\t\tconst knotsLength = knots ? knots.length - 1 : 0;\n\t\tconst pointsLength = controlPoints ? controlPoints.length : 0;\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || knotsLength;\n\n\t\tfor ( let i = 0; i < pointsLength; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tconst point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tconst hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w !== 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\tconst tangent = optionalTarget;\n\n\t\tconst u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tconst ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\ttangent.copy( ders[ 1 ] ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.degree = this.degree;\n\t\tdata.knots = [ ...this.knots ];\n\t\tdata.controlPoints = this.controlPoints.map( p => p.toArray() );\n\t\tdata.startKnot = this.startKnot;\n\t\tdata.endKnot = this.endKnot;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.degree = json.degree;\n\t\tthis.knots = [ ...json.knots ];\n\t\tthis.controlPoints = json.controlPoints.map( p => new Vector4( p[ 0 ], p[ 1 ], p[ 2 ], p[ 3 ] ) );\n\t\tthis.startKnot = json.startKnot;\n\t\tthis.endKnot = json.endKnot;\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { NURBSCurve };", "import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tEquirectangularReflectionMapping,\n\tEuler,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix3,\n\tMatrix4,\n\tMesh,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tPerspectiveCamera,\n\tPointLight,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tShapeUtils,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tUint16BufferAttribute,\n\tVector2,\n\tVector3,\n\tVector4,\n\tVectorKeyframeTrack\n} from 'three';\n\nimport * as fflate from '../libs/fflate.module.js';\nimport { NURBSCurve } from '../curves/NURBSCurve.js';\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nlet fbxTree;\nlet connections;\nlet sceneGraph;\n\nclass FBXLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( FBXBuffer, path ) {\n\n\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t} else {\n\n\t\t\tconst FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t}\n\n\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t}\n\n\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t}\n\n\t\t// console.log( fbxTree );\n\n\t\tconst textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t}\n\n}\n\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\nclass FBXTreeParser {\n\n\tconstructor( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tparse() {\n\n\t\tconnections = this.parseConnections();\n\n\t\tconst images = this.parseImages();\n\t\tconst textures = this.parseTextures( images );\n\t\tconst materials = this.parseMaterials( textures );\n\t\tconst deformers = this.parseDeformers();\n\t\tconst geometryMap = new GeometryParser().parse( deformers );\n\n\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tparseConnections() {\n\n\t\tconst connectionMap = new Map();\n\n\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\tconst rawConnections = fbxTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tconst fromID = rawConnection[ 0 ];\n\t\t\t\tconst toID = rawConnection[ 1 ];\n\t\t\t\tconst relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tconst childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tparseImages() {\n\n\t\tconst images = {};\n\t\tconst blobs = {};\n\n\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\tconst videoNodes = fbxTree.Objects.Video;\n\n\t\t\tfor ( const nodeID in videoNodes ) {\n\n\t\t\t\tconst videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tconst id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tconst arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tconst base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tconst image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( const id in images ) {\n\n\t\t\tconst filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tparseImage( videoNode ) {\n\n\t\tconst content = videoNode.Content;\n\t\tconst fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tconst extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tlet type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tga':\n\n\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t}\n\n\t\t\t\ttype = 'image/tga';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tconst array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tparseTextures( images ) {\n\n\t\tconst textureMap = new Map();\n\n\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\tconst textureNodes = fbxTree.Objects.Texture;\n\t\t\tfor ( const nodeID in textureNodes ) {\n\n\t\t\t\tconst texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tparseTexture( textureNode, images ) {\n\n\t\tconst texture = this.loadTexture( textureNode, images );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tconst wrapModeU = textureNode.WrapModeU;\n\t\tconst wrapModeV = textureNode.WrapModeV;\n\n\t\tconst valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tconst valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tconst values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\tif ( 'Translation' in textureNode ) {\n\n\t\t\tconst values = textureNode.Translation.value;\n\n\t\t\ttexture.offset.x = values[ 0 ];\n\t\t\ttexture.offset.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\tloadTexture( textureNode, images ) {\n\n\t\tconst nonNativeExtensions = new Set( [ 'tga', 'tif', 'tiff', 'exr', 'dds', 'hdr', 'ktx2' ] );\n\n\t\tconst extension = textureNode.FileName.split( '.' ).pop().toLowerCase();\n\n\t\tconst loader = nonNativeExtensions.has( extension ) ? this.manager.getHandler( `.${extension}` ) : this.textureLoader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t`FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,\n\t\t\t\ttextureNode.RelativeFilename\n\t\t\t);\n\t\t\treturn new Texture();\n\n\t\t}\n\n\t\tconst loaderPath = loader.path;\n\n\t\tif ( ! loaderPath ) {\n\n\t\t\tloader.setPath( this.textureLoader.path );\n\n\t\t}\n\n\t\tconst children = connections.get( textureNode.id ).children;\n\n\t\tlet fileName;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tloader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst texture = loader.load( fileName );\n\n\t\t// revert to initial path\n\t\tloader.setPath( loaderPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tparseMaterials( textureMap ) {\n\n\t\tconst materialMap = new Map();\n\n\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\tconst materialNodes = fbxTree.Objects.Material;\n\n\t\t\tfor ( const nodeID in materialNodes ) {\n\n\t\t\t\tconst material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tparseMaterial( materialNode, textureMap ) {\n\n\t\tconst ID = materialNode.id;\n\t\tconst name = materialNode.attrName;\n\t\tlet type = materialNode.ShadingModel;\n\n\t\t// Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tconst parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\tlet material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tparseParameters( materialNode, textureMap, ID ) {\n\n\t\tconst parameters = {};\n\n\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Diffuse ) {\n\n\t\t\tparameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Diffuse.value ), SRGBColorSpace );\n\n\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\tparameters.color = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.DiffuseColor.value ), SRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Emissive ) {\n\n\t\t\tparameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Emissive.value ), SRGBColorSpace );\n\n\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\tparameters.emissive = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.EmissiveColor.value ), SRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t}\n\n\t\t// the transparency handling is implemented based on Blender/Unity's approach: https://github.com/sobotka/blender-addons/blob/7d80f2f97161fc8e353a657b179b9aa1f8e5280b/io_scene_fbx/import_fbx.py#L1444-L1459\n\n\t\tparameters.opacity = 1 - ( materialNode.TransparencyFactor ? parseFloat( materialNode.TransparencyFactor.value ) : 0 );\n\n\t\tif ( parameters.opacity === 1 || parameters.opacity === 0 ) {\n\n\t\t\tparameters.opacity = ( materialNode.Opacity ? parseFloat( materialNode.Opacity.value ) : null );\n\n\t\t\tif ( parameters.opacity === null ) {\n\n\t\t\t\tparameters.opacity = 1 - ( materialNode.TransparentColor ? parseFloat( materialNode.TransparentColor.value[ 0 ] ) : 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\n\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t}\n\n\t\tif ( materialNode.Shininess ) {\n\n\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t}\n\n\t\tif ( materialNode.Specular ) {\n\n\t\t\tparameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.Specular.value ), SRGBColorSpace );\n\n\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\tparameters.specular = ColorManagement.toWorkingColorSpace( new Color().fromArray( materialNode.SpecularColor.value ), SRGBColorSpace );\n\n\t\t}\n\n\t\tconst scope = this;\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tconst type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.map !== undefined ) {\n\n\t\t\t\t\t\tparameters.map.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.emissiveMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.emissiveMap.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.envMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.envMap.mapping = EquirectangularReflectionMapping;\n\t\t\t\t\t\tparameters.envMap.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tif ( parameters.specularMap !== undefined ) {\n\n\t\t\t\t\t\tparameters.specularMap.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tgetTexture( textureMap, id ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tparseDeformers() {\n\n\t\tconst skeletons = {};\n\t\tconst morphTargets = {};\n\n\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\tconst DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\tfor ( const nodeID in DeformerNodes ) {\n\n\t\t\t\tconst deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tconst skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tconst morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tparseSkeleton( relationships, deformerNodes ) {\n\n\t\tconst rawBones = [];\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tconst rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tparseMorphTargets( relationships, deformerNodes ) {\n\n\t\tconst rawMorphTargets = [];\n\n\t\tfor ( let i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tconst child = relationships.children[ i ];\n\n\t\t\tconst morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tconst rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t} )[ 0 ].ID;\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// create the main Group() to be returned by the loader\n\tparseScene( deformers, geometryMap, materialMap ) {\n\n\t\tsceneGraph = new Group();\n\n\t\tconst modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tconst scope = this;\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tconst modelNode = modelNodes[ model.ID ];\n\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\tconst parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tconst parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\tthis.addGlobalSceneSettings();\n\n\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t}\n\n\t\t\t\tconst transform = generateTransform( node.userData.transformData );\n\n\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst animations = new AnimationParser().parse();\n\n\t\t// if all the models where already combined in a single group, just return that\n\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t}\n\n\t\tsceneGraph.animations = animations;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tparseModels( skeletons, geometryMap, materialMap ) {\n\n\t\tconst modelMap = new Map();\n\t\tconst modelNodes = fbxTree.Objects.Model;\n\n\t\tfor ( const nodeID in modelNodes ) {\n\n\t\t\tconst id = parseInt( nodeID );\n\t\t\tconst node = modelNodes[ nodeID ];\n\t\t\tconst relationships = connections.get( id );\n\n\t\t\tlet model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\tmodel = new Bone();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';\n\t\t\t\tmodel.userData.originalName = node.attrName;\n\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tthis.getTransformData( model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tbuildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tlet bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( const ID in skeletons ) {\n\n\t\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tconst subBone = bone;\n\t\t\t\t\t\tbone = new Bone();\n\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\tbone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\tbone.userData.originalName = name;\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a PerspectiveCamera or OrthographicCamera\n\tcreateCamera( relationships ) {\n\n\t\tlet model;\n\t\tlet cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new Object3D();\n\n\t\t} else {\n\n\t\t\tlet type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tlet nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tlet farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tlet width = window.innerWidth;\n\t\t\tlet height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tconst aspect = width / height;\n\n\t\t\tlet fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tconst focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Orthographic cameras not supported yet.' );\n\t\t\t\t\tmodel = new Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a DirectionalLight, PointLight or SpotLight\n\tcreateLight( relationships ) {\n\n\t\tlet model;\n\t\tlet lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tconst attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new Object3D();\n\n\t\t} else {\n\n\t\t\tlet type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tlet color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = ColorManagement.toWorkingColorSpace( new Color().fromArray( lightAttribute.Color.value ), SRGBColorSpace );\n\n\t\t\t}\n\n\t\t\tlet intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tlet distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tconst decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tlet angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = MathUtils.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\tmodel = new PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateMesh( relationships, geometryMap, materialMap ) {\n\n\t\tlet model;\n\t\tlet geometry = null;\n\t\tlet material = null;\n\t\tconst materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new MeshPhongMaterial( {\n\t\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\t\tcolor: 0xcccccc\n\t\t\t} );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmodel = new SkinnedMesh( geometry, material );\n\t\t\tmodel.normalizeSkinWeights();\n\n\t\t} else {\n\n\t\t\tmodel = new Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tcreateCurve( relationships, geometryMap ) {\n\n\t\tconst geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tconst material = new LineBasicMaterial( {\n\t\t\tname: Loader.DEFAULT_MATERIAL_NAME,\n\t\t\tcolor: 0x3300ff,\n\t\t\tlinewidth: 1\n\t\t} );\n\t\treturn new Line( geometry, material );\n\n\t}\n\n\t// parse the model node for transform data\n\tgetTransformData( model, modelNode ) {\n\n\t\tconst transformData = {};\n\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\telse transformData.eulerOrder = getEulerOrder( 0 );\n\n\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\tmodel.userData.transformData = transformData;\n\n\t}\n\n\tsetLookAtProperties( model, modelNode ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tconst children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tconst lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tconst pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tbindSkeleton( skeletons, geometryMap, modelMap ) {\n\n\t\tconst bindMatrices = this.parsePoseNodes();\n\n\t\tfor ( const ID in skeletons ) {\n\n\t\t\tconst skeleton = skeletons[ ID ];\n\n\t\t\tconst parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tconst geoID = parent.ID;\n\t\t\t\t\tconst geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tconst model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tparsePoseNodes() {\n\n\t\tconst bindMatrices = {};\n\n\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\tconst BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\tfor ( const nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {\n\n\t\t\t\t\tconst poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\taddGlobalSceneSettings() {\n\n\t\tif ( 'GlobalSettings' in fbxTree ) {\n\n\t\t\tif ( 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\t// Parse ambient color - if it's not set to black (default), create an ambient light\n\n\t\t\t\tconst ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\tconst r = ambientColor[ 0 ];\n\t\t\t\tconst g = ambientColor[ 1 ];\n\t\t\t\tconst b = ambientColor[ 2 ];\n\n\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\tconst color = new Color().setRGB( r, g, b, SRGBColorSpace );\n\t\t\t\t\tsceneGraph.add( new AmbientLight( color, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( 'UnitScaleFactor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\tsceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n// parse Geometry data from FBXTree and return map of BufferGeometries\nclass GeometryParser {\n\n\tconstructor() {\n\n\t\tthis.negativeMaterialIndices = false;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tparse( deformers ) {\n\n\t\tconst geometryMap = new Map();\n\n\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\tconst geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\tfor ( const nodeID in geoNodes ) {\n\n\t\t\t\tconst relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tconst geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// report warnings\n\n\t\tif ( this.negativeMaterialIndices === true ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tparseGeometry( relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tparseMeshGeometry( relationships, geoNode, deformers ) {\n\n\t\tconst skeletons = deformers.skeletons;\n\t\tconst morphTargets = [];\n\n\t\tconst modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tconst skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Assume one model and get the preRotation from that\n\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\tconst modelNode = modelNodes[ 0 ];\n\n\t\tconst transformData = {};\n\n\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\tconst transform = generateTransform( transformData );\n\n\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t}\n\n\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\tgenGeometry( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\tconst geo = new BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tconst geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\tconst buffers = this.genBuffers( geoInfo );\n\n\t\tconst positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( preTransform );\n\n\t\t\tconst normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );\n\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\tconst name = i === 0 ? 'uv' : `uv${ i }`;\n\n\t\t\tgeo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tlet prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tlet startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tconst lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tconst lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tparseGeoNode( geoNode, skeleton ) {\n\n\t\tconst geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tlet i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tgenBuffers( geoInfo ) {\n\n\t\tconst buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tlet polygonIndex = 0;\n\t\tlet faceLength = 0;\n\t\tlet displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tlet facePositionIndexes = [];\n\t\tlet faceNormals = [];\n\t\tlet faceColors = [];\n\t\tlet faceUVs = [];\n\t\tlet faceWeights = [];\n\t\tlet faceWeightIndices = [];\n\n\t\tconst scope = this;\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tlet materialIndex;\n\t\t\tlet endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tlet weightIndices = [];\n\t\t\tlet weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tconst Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tlet currentWeight = weight;\n\t\t\t\t\t\tlet currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tconst tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tmaterialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\tif ( materialIndex < 0 ) {\n\n\t\t\t\t\tscope.negativeMaterialIndices = true;\n\t\t\t\t\tmaterialIndex = 0; // fallback\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tconst data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal\n\tgetNormalNewell( vertices ) {\n\n\t\tconst normal = new Vector3( 0.0, 0.0, 0.0 );\n\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tconst current = vertices[ i ];\n\t\t\tconst next = vertices[ ( i + 1 ) % vertices.length ];\n\n\t\t\tnormal.x += ( current.y - next.y ) * ( current.z + next.z );\n\t\t\tnormal.y += ( current.z - next.z ) * ( current.x + next.x );\n\t\t\tnormal.z += ( current.x - next.x ) * ( current.y + next.y );\n\n\t\t}\n\n\t\tnormal.normalize();\n\n\t\treturn normal;\n\n\t}\n\n\tgetNormalTangentAndBitangent( vertices ) {\n\n\t\tconst normalVector = this.getNormalNewell( vertices );\n\t\t// Avoid up being equal or almost equal to normalVector\n\t\tconst up = Math.abs( normalVector.z ) > 0.5 ? new Vector3( 0.0, 1.0, 0.0 ) : new Vector3( 0.0, 0.0, 1.0 );\n\t\tconst tangent = up.cross( normalVector ).normalize();\n\t\tconst bitangent = normalVector.clone().cross( tangent ).normalize();\n\n\t\treturn {\n\t\t\tnormal: normalVector,\n\t\t\ttangent: tangent,\n\t\t\tbitangent: bitangent\n\t\t};\n\n\t}\n\n\tflattenVertex( vertex, normalTangent, normalBitangent ) {\n\n\t\treturn new Vector2(\n\t\t\tvertex.dot( normalTangent ),\n\t\t\tvertex.dot( normalBitangent )\n\t\t);\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tlet triangles;\n\n\t\tif ( faceLength > 3 ) {\n\n\t\t\t// Triangulate n-gon using earcut\n\n\t\t\tconst vertices = [];\n\t\t\t// in morphing scenario vertexPositions represent morphPositions\n\t\t\t// while baseVertexPositions represent the original geometry's positions\n\t\t\tconst positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;\n\t\t\tfor ( let i = 0; i < facePositionIndexes.length; i += 3 ) {\n\n\t\t\t\tvertices.push(\n\t\t\t\t\tnew Vector3(\n\t\t\t\t\t\tpositions[ facePositionIndexes[ i ] ],\n\t\t\t\t\t\tpositions[ facePositionIndexes[ i + 1 ] ],\n\t\t\t\t\t\tpositions[ facePositionIndexes[ i + 2 ] ]\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tconst { tangent, bitangent } = this.getNormalTangentAndBitangent( vertices );\n\t\t\tconst triangulationInput = [];\n\n\t\t\tfor ( const vertex of vertices ) {\n\n\t\t\t\ttriangulationInput.push( this.flattenVertex( vertex, tangent, bitangent ) );\n\n\t\t\t}\n\n\t\t\t// When vertices is an array of [0,0,0] elements (which is the case for vertices not participating in morph)\n\t\t\t// the triangulationInput will be an array of [0,0] elements\n\t\t\t// resulting in an array of 0 triangles being returned from ShapeUtils.triangulateShape\n\t\t\t// leading to not pushing into buffers.vertex the redundant vertices (the vertices that are not morphed).\n\t\t\t// That's why, in order to support morphing scenario, \"positions\" is looking first for baseVertexPositions,\n\t\t\t// so that we don't end up with an array of 0 triangles for the faces not participating in morph.\n\t\t\ttriangles = ShapeUtils.triangulateShape( triangulationInput, [] );\n\n\t\t} else {\n\n\t\t\t// Regular triangle, skip earcut triangulation step\n\t\t\ttriangles = [[ 0, 1, 2 ]];\n\n\t\t}\n\n\t\tfor ( const [ i0, i1, i2 ] of triangles ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i0 * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i1 * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i2 * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i0 * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i0 * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i0 * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i0 * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i1 * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i1 * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i1 * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i1 * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i2 * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i2 * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i2 * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i2 * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i0 * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i0 * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i1 * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i1 * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i2 * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i2 * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ i0 * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i0 * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i0 * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i1 * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i1 * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i1 * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i2 * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i2 * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i2 * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i0 * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i0 * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i0 * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i1 * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i1 * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i1 * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i2 * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i2 * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i2 * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i0 * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i1 * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i2 * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddMorphTargets( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\tif ( morphTargets.length === 0 ) return;\n\n\t\tparentGeo.morphTargetsRelative = true;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\tconst scope = this;\n\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\tconst morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\tconst basePositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a : [];\n\t\tconst baseIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\tconst morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n\t\tconst morphIndices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n\t\tconst length = parentGeo.attributes.position.count * 3;\n\t\tconst morphPositions = new Float32Array( length );\n\n\t\tfor ( let i = 0; i < morphIndices.length; i ++ ) {\n\n\t\t\tconst morphIndex = morphIndices[ i ] * 3;\n\n\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tconst morphGeoInfo = {\n\t\t\tvertexIndices: baseIndices,\n\t\t\tvertexPositions: morphPositions,\n\t\t\tbaseVertexPositions: basePositions\n\t\t};\n\n\t\tconst morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\tconst positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tparseNormals( NormalNode ) {\n\n\t\tconst mappingType = NormalNode.MappingInformationType;\n\t\tconst referenceType = NormalNode.ReferenceInformationType;\n\t\tconst buffer = NormalNode.Normals.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tparseUVs( UVNode ) {\n\n\t\tconst mappingType = UVNode.MappingInformationType;\n\t\tconst referenceType = UVNode.ReferenceInformationType;\n\t\tconst buffer = UVNode.UV.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tparseVertexColors( ColorNode ) {\n\n\t\tconst mappingType = ColorNode.MappingInformationType;\n\t\tconst referenceType = ColorNode.ReferenceInformationType;\n\t\tconst buffer = ColorNode.Colors.a;\n\t\tlet indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\tfor ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {\n\n\t\t\tc.fromArray( buffer, i );\n\t\t\tColorManagement.toWorkingColorSpace( c, SRGBColorSpace );\n\t\t\tc.toArray( buffer, i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tparseMaterialIndices( MaterialNode ) {\n\n\t\tconst mappingType = MaterialNode.MappingInformationType;\n\t\tconst referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tconst materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tconst materialIndices = [];\n\n\t\tfor ( let i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tparseNurbsGeometry( geoNode ) {\n\n\t\tconst order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new BufferGeometry();\n\n\t\t}\n\n\t\tconst degree = order - 1;\n\n\t\tconst knots = geoNode.KnotVector.a;\n\t\tconst controlPoints = [];\n\t\tconst pointsValues = geoNode.Points.a;\n\n\t\tfor ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tlet startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( let i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tconst points = curve.getPoints( controlPoints.length * 12 );\n\n\t\treturn new BufferGeometry().setFromPoints( points );\n\n\t}\n\n}\n\n// parse animation data from FBXTree\nclass AnimationParser {\n\n\t// take raw animation clips and turn them into three.js animation clips\n\tparse() {\n\n\t\tconst animationClips = [];\n\n\t\tconst rawClips = this.parseClips();\n\n\t\tif ( rawClips !== undefined ) {\n\n\t\t\tfor ( const key in rawClips ) {\n\n\t\t\t\tconst rawClip = rawClips[ key ];\n\n\t\t\t\tconst clip = this.addClip( rawClip );\n\n\t\t\t\tanimationClips.push( clip );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animationClips;\n\n\t}\n\n\tparseClips() {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tconst curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\tconst layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\tconst rawClips = this.parseAnimStacks( layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tparseAnimationCurveNodes() {\n\n\t\tconst rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\tconst curveNodesMap = new Map();\n\n\t\tfor ( const nodeID in rawCurveNodes ) {\n\n\t\t\tconst rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\tconst curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tparseAnimationCurves( curveNodesMap ) {\n\n\t\tconst rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t// clearly, this should be optimised to\n\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\tfor ( const nodeID in rawCurves ) {\n\n\t\t\tconst animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tconst relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tconst animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tconst animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tparseAnimationLayers( curveNodesMap ) {\n\n\t\tconst rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\tconst layersMap = new Map();\n\n\t\tfor ( const nodeID in rawLayers ) {\n\n\t\t\tconst layerCurveNodes = [];\n\n\t\t\tconst connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tconst children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tconst curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new Matrix4();\n\n\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconst deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\tconst geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\tconst modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\tconst rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\tconst node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\tparseAnimStacks( layersMap ) {\n\n\t\tconst rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tconst rawClips = {};\n\n\t\tfor ( const nodeID in rawStacks ) {\n\n\t\t\tconst children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tconst layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\taddClip( rawClip ) {\n\n\t\tlet tracks = [];\n\n\t\tconst scope = this;\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tgenerateTracks( rawTracks ) {\n\n\t\tconst tracks = [];\n\n\t\tlet initialPosition = new Vector3();\n\t\tlet initialScale = new Vector3();\n\n\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, new Quaternion(), initialScale );\n\n\t\tinitialPosition = initialPosition.toArray();\n\t\tinitialScale = initialScale.toArray();\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tconst positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tconst rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tconst scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\tconst morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tgenerateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tconst times = this.getTimesForAllAxes( curves );\n\t\tconst values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tgenerateRotationTrack( modelName, curves, preRotation, postRotation, eulerOrder ) {\n\n\t\tlet times;\n\t\tlet values;\n\n\t\tif ( curves.x !== undefined && curves.y !== undefined && curves.z !== undefined ) {\n\n\t\t\tconst result = this.interpolateRotations( curves.x, curves.y, curves.z, eulerOrder );\n\n\t\t\ttimes = result[ 0 ];\n\t\t\tvalues = result[ 1 ];\n\n\t\t}\n\n\t\t// For Maya models using \"Joint Orient\", Euler order only applies to rotation, not pre/post-rotations\n\t\tconst defaultEulerOrder = getEulerOrder( 0 );\n\n\t\tif ( preRotation !== undefined ) {\n\n\t\t\tpreRotation = preRotation.map( MathUtils.degToRad );\n\t\t\tpreRotation.push( defaultEulerOrder );\n\n\t\t\tpreRotation = new Euler().fromArray( preRotation );\n\t\t\tpreRotation = new Quaternion().setFromEuler( preRotation );\n\n\t\t}\n\n\t\tif ( postRotation !== undefined ) {\n\n\t\t\tpostRotation = postRotation.map( MathUtils.degToRad );\n\t\t\tpostRotation.push( defaultEulerOrder );\n\n\t\t\tpostRotation = new Euler().fromArray( postRotation );\n\t\t\tpostRotation = new Quaternion().setFromEuler( postRotation ).invert();\n\n\t\t}\n\n\t\tconst quaternion = new Quaternion();\n\t\tconst euler = new Euler();\n\n\t\tconst quaternionValues = [];\n\n\t\tif ( ! values || ! times ) return new QuaternionKeyframeTrack( modelName + '.quaternion', [ 0 ], [ 0 ] );\n\n\t\tfor ( let i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t// Check unroll\n\t\t\tif ( i > 2 ) {\n\n\t\t\t\tconst prevQuat = new Quaternion().fromArray(\n\t\t\t\t\tquaternionValues,\n\t\t\t\t\t( ( i - 3 ) / 3 ) * 4\n\t\t\t\t);\n\n\t\t\t\tif ( prevQuat.dot( quaternion ) < 0 ) {\n\n\t\t\t\t\tquaternion.set( - quaternion.x, - quaternion.y, - quaternion.z, - quaternion.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tgenerateMorphTrack( rawTracks ) {\n\n\t\tconst curves = rawTracks.DeformPercent.curves.morph;\n\t\tconst values = curves.values.map( function ( val ) {\n\n\t\t\treturn val / 100;\n\n\t\t} );\n\n\t\tconst morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\treturn new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tgetTimesForAllAxes( curves ) {\n\n\t\tlet times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} );\n\n\t\t// and remove duplicates\n\t\tif ( times.length > 1 ) {\n\n\t\t\tlet targetIndex = 1;\n\t\t\tlet lastValue = times[ 0 ];\n\t\t\tfor ( let i = 1; i < times.length; i ++ ) {\n\n\t\t\t\tconst currentValue = times[ i ];\n\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t}\n\n\t\treturn times;\n\n\t}\n\n\tgetKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tconst prevValue = initialValue;\n\n\t\tconst values = [];\n\n\t\tlet xIndex = - 1;\n\t\tlet yIndex = - 1;\n\t\tlet zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tconst xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tconst yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tconst zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tinterpolateRotations( curvex, curvey, curvez, eulerOrder ) {\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\t// Add first frame\n\t\ttimes.push( curvex.times[ 0 ] );\n\t\tvalues.push( MathUtils.degToRad( curvex.values[ 0 ] ) );\n\t\tvalues.push( MathUtils.degToRad( curvey.values[ 0 ] ) );\n\t\tvalues.push( MathUtils.degToRad( curvez.values[ 0 ] ) );\n\n\t\tfor ( let i = 1; i < curvex.values.length; i ++ ) {\n\n\t\t\tconst initialValue = [\n\t\t\t\tcurvex.values[ i - 1 ],\n\t\t\t\tcurvey.values[ i - 1 ],\n\t\t\t\tcurvez.values[ i - 1 ],\n\t\t\t];\n\n\t\t\tif ( isNaN( initialValue[ 0 ] ) || isNaN( initialValue[ 1 ] ) || isNaN( initialValue[ 2 ] ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst initialValueRad = initialValue.map( MathUtils.degToRad );\n\n\t\t\tconst currentValue = [\n\t\t\t\tcurvex.values[ i ],\n\t\t\t\tcurvey.values[ i ],\n\t\t\t\tcurvez.values[ i ],\n\t\t\t];\n\n\t\t\tif ( isNaN( currentValue[ 0 ] ) || isNaN( currentValue[ 1 ] ) || isNaN( currentValue[ 2 ] ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValueRad = currentValue.map( MathUtils.degToRad );\n\n\t\t\tconst valuesSpan = [\n\t\t\t\tcurrentValue[ 0 ] - initialValue[ 0 ],\n\t\t\t\tcurrentValue[ 1 ] - initialValue[ 1 ],\n\t\t\t\tcurrentValue[ 2 ] - initialValue[ 2 ],\n\t\t\t];\n\n\t\t\tconst absoluteSpan = [\n\t\t\t\tMath.abs( valuesSpan[ 0 ] ),\n\t\t\t\tMath.abs( valuesSpan[ 1 ] ),\n\t\t\t\tMath.abs( valuesSpan[ 2 ] ),\n\t\t\t];\n\n\t\t\tif ( absoluteSpan[ 0 ] >= 180 || absoluteSpan[ 1 ] >= 180 || absoluteSpan[ 2 ] >= 180 ) {\n\n\t\t\t\tconst maxAbsSpan = Math.max( ...absoluteSpan );\n\n\t\t\t\tconst numSubIntervals = maxAbsSpan / 180;\n\n\t\t\t\tconst E1 = new Euler( ...initialValueRad, eulerOrder );\n\t\t\t\tconst E2 = new Euler( ...currentValueRad, eulerOrder );\n\n\t\t\t\tconst Q1 = new Quaternion().setFromEuler( E1 );\n\t\t\t\tconst Q2 = new Quaternion().setFromEuler( E2 );\n\n\t\t\t\t// Check unroll\n\t\t\t\tif ( Q1.dot( Q2 ) ) {\n\n\t\t\t\t\tQ2.set( - Q2.x, - Q2.y, - Q2.z, - Q2.w );\n\n\t\t\t\t}\n\n\t\t\t\t// Interpolate\n\t\t\t\tconst initialTime = curvex.times[ i - 1 ];\n\t\t\t\tconst timeSpan = curvex.times[ i ] - initialTime;\n\n\t\t\t\tconst Q = new Quaternion();\n\t\t\t\tconst E = new Euler();\n\t\t\t\tfor ( let t = 0; t < 1; t += 1 / numSubIntervals ) {\n\n\t\t\t\t\tQ.copy( Q1.clone().slerp( Q2.clone(), t ) );\n\n\t\t\t\t\ttimes.push( initialTime + t * timeSpan );\n\t\t\t\t\tE.setFromQuaternion( Q, eulerOrder );\n\n\t\t\t\t\tvalues.push( E.x );\n\t\t\t\t\tvalues.push( E.y );\n\t\t\t\t\tvalues.push( E.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttimes.push( curvex.times[ i ] );\n\t\t\t\tvalues.push( MathUtils.degToRad( curvex.values[ i ] ) );\n\t\t\t\tvalues.push( MathUtils.degToRad( curvey.values[ i ] ) );\n\t\t\t\tvalues.push( MathUtils.degToRad( curvez.values[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn [ times, values ];\n\n\t}\n\n}\n\n// parse an FBX file in ASCII format\nclass TextParser {\n\n\tgetPrevNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t}\n\n\tgetCurrentNode() {\n\n\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t}\n\n\tgetCurrentProp() {\n\n\t\treturn this.currentProp;\n\n\t}\n\n\tpushStack( node ) {\n\n\t\tthis.nodeStack.push( node );\n\t\tthis.currentIndent += 1;\n\n\t}\n\n\tpopStack() {\n\n\t\tthis.nodeStack.pop();\n\t\tthis.currentIndent -= 1;\n\n\t}\n\n\tsetCurrentProp( val, name ) {\n\n\t\tthis.currentProp = val;\n\t\tthis.currentPropName = name;\n\n\t}\n\n\tparse( text ) {\n\n\t\tthis.currentIndent = 0;\n\n\t\tthis.allNodes = new FBXTree();\n\t\tthis.nodeStack = [];\n\t\tthis.currentProp = [];\n\t\tthis.currentPropName = '';\n\n\t\tconst scope = this;\n\n\t\tconst split = text.split( /[\\r\\n]+/ );\n\n\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\tconst matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\tconst matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\tconst matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\tconst matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\tconst matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\tif ( matchBeginning ) {\n\n\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\tscope.popStack();\n\n\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.allNodes;\n\n\t}\n\n\tparseNodeBegin( line, property ) {\n\n\t\tconst nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\tconst nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t} );\n\n\t\tconst node = { name: nodeName };\n\t\tconst attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\t// a top node\n\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t} else { // a subnode\n\n\t\t\t// if the subnode already exists, append it\n\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\tthis.pushStack( node );\n\n\t}\n\n\tparseNodeAttr( attrs ) {\n\n\t\tlet id = attrs[ 0 ];\n\n\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet name = '', type = '';\n\n\t\tif ( attrs.length > 1 ) {\n\n\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\ttype = attrs[ 2 ];\n\n\t\t}\n\n\t\treturn { id: id, name: name, type: type };\n\n\t}\n\n\tparseNodeProperty( line, property, contentLine ) {\n\n\t\tlet propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\tlet propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t//\tContent: ,\n\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t}\n\n\t\tconst currentNode = this.getCurrentNode();\n\t\tconst parentName = currentNode.name;\n\n\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Connections\n\t\tif ( propName === 'C' ) {\n\n\t\t\tconst connProps = propValue.split( ',' ).slice( 1 );\n\t\t\tconst from = parseInt( connProps[ 0 ] );\n\t\t\tconst to = parseInt( connProps[ 1 ] );\n\n\t\t\tlet rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t} );\n\n\t\t\tpropName = 'connections';\n\t\t\tpropValue = [ from, to ];\n\t\t\tappend( propValue, rest );\n\n\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Node\n\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t// connections\n\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t} else {\n\n\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\telse currentNode.a = propValue;\n\n\t\t}\n\n\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t}\n\n\t}\n\n\tparseNodePropertyContinued( line ) {\n\n\t\tconst currentNode = this.getCurrentNode();\n\n\t\tcurrentNode.a += line;\n\n\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t// so convert the string to an array\n\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t}\n\n\t}\n\n\t// parse \"Property70\"\n\tparseNodeSpecialProperty( line, propName, propValue ) {\n\n\t\t// split this\n\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t// into array like below\n\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\tconst props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t} );\n\n\t\tconst innerPropName = props[ 0 ];\n\t\tconst innerPropType1 = props[ 1 ];\n\t\tconst innerPropType2 = props[ 2 ];\n\t\tconst innerPropFlag = props[ 3 ];\n\t\tlet innerPropValue = props[ 4 ];\n\n\t\t// cast values where needed, otherwise leave as strings\n\t\tswitch ( innerPropType1 ) {\n\n\t\t\tcase 'int':\n\t\t\tcase 'enum':\n\t\t\tcase 'bool':\n\t\t\tcase 'ULongLong':\n\t\t\tcase 'double':\n\t\t\tcase 'Number':\n\t\t\tcase 'FieldOfView':\n\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t\tcase 'Color':\n\t\t\tcase 'ColorRGB':\n\t\t\tcase 'Vector3D':\n\t\t\tcase 'Lcl_Translation':\n\t\t\tcase 'Lcl_Rotation':\n\t\t\tcase 'Lcl_Scaling':\n\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// CAUTION: these props must append to parent's parent\n\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t'type': innerPropType1,\n\t\t\t'type2': innerPropType2,\n\t\t\t'flag': innerPropFlag,\n\t\t\t'value': innerPropValue\n\n\t\t};\n\n\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t}\n\n}\n\n// Parse an FBX file in Binary format\nclass BinaryParser {\n\n\tparse( buffer ) {\n\n\t\tconst reader = new BinaryReader( buffer );\n\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\tconst version = reader.getUint32();\n\n\t\tif ( version < 6400 ) {\n\n\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t}\n\n\t\tconst allNodes = new FBXTree();\n\n\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\tconst node = this.parseNode( reader, version );\n\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t}\n\n\t\treturn allNodes;\n\n\t}\n\n\t// Check if reader has reached the end of content.\n\tendOfContent( reader ) {\n\n\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t// - 16bytes: magic\n\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t// - 4bytes: magic\n\t\t// - 4bytes: version\n\t\t// - 120bytes: zero\n\t\t// - 16bytes: magic\n\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t} else {\n\n\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t}\n\n\t}\n\n\t// recursively parse nodes until the end of the file is reached\n\tparseNode( reader, version ) {\n\n\t\tconst node = {};\n\n\t\t// The first three data sizes depends on version.\n\t\tconst endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\tconst numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\tconst nameLen = reader.getUint8();\n\t\tconst name = reader.getString( nameLen );\n\n\t\t// Regards this node as NULL-record if endOffset is zero\n\t\tif ( endOffset === 0 ) return null;\n\n\t\tconst propertyList = [];\n\n\t\tfor ( let i = 0; i < numProperties; i ++ ) {\n\n\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t}\n\n\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\tconst id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\tconst attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\tconst attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t// check if this node represents just a single property\n\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\tconst subNode = this.parseNode( reader, version );\n\n\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t}\n\n\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\tif ( typeof id === 'number' ) node.id = id;\n\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\tif ( name !== '' ) node.name = name;\n\n\t\treturn node;\n\n\t}\n\n\tparseSubNode( name, node, subNode ) {\n\n\t\t// special case: child node is single property\n\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\tconst value = subNode.propertyList[ 0 ];\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\tsubNode.a = value;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t}\n\n\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\tconst array = [];\n\n\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t} );\n\n\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\tnode.connections = [];\n\n\t\t\t}\n\n\t\t\tnode.connections.push( array );\n\n\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\tconst keys = Object.keys( subNode );\n\n\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t} );\n\n\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\tlet innerPropName = subNode.propertyList[ 0 ];\n\t\t\tlet innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\tconst innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\tconst innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\tlet innerPropValue;\n\n\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\tinnerPropValue = [\n\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t];\n\n\t\t\t} else {\n\n\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t}\n\n\t\t\t// this will be copied to parent, see above\n\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t} else {\n\n\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t}\n\n\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparseProperty( reader ) {\n\n\t\tconst type = reader.getString( 1 );\n\t\tlet length;\n\n\t\tswitch ( type ) {\n\n\t\t\tcase 'C':\n\t\t\t\treturn reader.getBoolean();\n\n\t\t\tcase 'D':\n\t\t\t\treturn reader.getFloat64();\n\n\t\t\tcase 'F':\n\t\t\t\treturn reader.getFloat32();\n\n\t\t\tcase 'I':\n\t\t\t\treturn reader.getInt32();\n\n\t\t\tcase 'L':\n\t\t\t\treturn reader.getInt64();\n\n\t\t\tcase 'R':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\tcase 'S':\n\t\t\t\tlength = reader.getUint32();\n\t\t\t\treturn reader.getString( length );\n\n\t\t\tcase 'Y':\n\t\t\t\treturn reader.getInt16();\n\n\t\t\tcase 'b':\n\t\t\tcase 'c':\n\t\t\tcase 'd':\n\t\t\tcase 'f':\n\t\t\tcase 'i':\n\t\t\tcase 'l':\n\n\t\t\t\tconst arrayLength = reader.getUint32();\n\t\t\t\tconst encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\tconst compressedLength = reader.getUint32();\n\n\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst data = fflate.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );\n\t\t\t\tconst reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\tcase 'f':\n\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\tcase 'i':\n\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t}\n\n\t\t\t\tbreak; // cannot happen but is required by the DeepScan\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t}\n\n\t}\n\n}\n\nclass BinaryReader {\n\n\tconstructor( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\t\tthis._textDecoder = new TextDecoder();\n\n\t}\n\n\tgetOffset() {\n\n\t\treturn this.offset;\n\n\t}\n\n\tsize() {\n\n\t\treturn this.dv.buffer.byteLength;\n\n\t}\n\n\tskip( length ) {\n\n\t\tthis.offset += length;\n\n\t}\n\n\t// seems like true/false representation depends on exporter.\n\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t// then sees LSB.\n\tgetBoolean() {\n\n\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t}\n\n\tgetBooleanArray( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getBoolean() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint8() {\n\n\t\tconst value = this.dv.getUint8( this.offset );\n\t\tthis.offset += 1;\n\t\treturn value;\n\n\t}\n\n\tgetInt16() {\n\n\t\tconst value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\tthis.offset += 2;\n\t\treturn value;\n\n\t}\n\n\tgetInt32() {\n\n\t\tconst value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetInt32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetUint32() {\n\n\t\tconst value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t// There's a possibility that this method returns wrong value if the value\n\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t// TODO: safely handle 64-bit integer\n\tgetInt64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\t// calculate negative value\n\t\tif ( high & 0x80000000 ) {\n\n\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetInt64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getInt64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// Note: see getInt64() comment\n\tgetUint64() {\n\n\t\tlet low, high;\n\n\t\tif ( this.littleEndian ) {\n\n\t\t\tlow = this.getUint32();\n\t\t\thigh = this.getUint32();\n\n\t\t} else {\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\n\t\t}\n\n\t\treturn high * 0x100000000 + low;\n\n\t}\n\n\tgetFloat32() {\n\n\t\tconst value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\tthis.offset += 4;\n\t\treturn value;\n\n\t}\n\n\tgetFloat32Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat32() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetFloat64() {\n\n\t\tconst value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\tthis.offset += 8;\n\t\treturn value;\n\n\t}\n\n\tgetFloat64Array( size ) {\n\n\t\tconst a = [];\n\n\t\tfor ( let i = 0; i < size; i ++ ) {\n\n\t\t\ta.push( this.getFloat64() );\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\tgetArrayBuffer( size ) {\n\n\t\tconst value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\tthis.offset += size;\n\t\treturn value;\n\n\t}\n\n\tgetString( size ) {\n\n\t\tconst start = this.offset;\n\t\tlet a = new Uint8Array( this.dv.buffer, start, size );\n\n\t\tthis.skip( size );\n\n\t\tconst nullByte = a.indexOf( 0 );\n\t\tif ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );\n\n\t\treturn this._textDecoder.decode( a );\n\n\t}\n\n}\n\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\nclass FBXTree {\n\n\tadd( key, val ) {\n\n\t\tthis[ key ] = val;\n\n\t}\n\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction isFbxFormatBinary( buffer ) {\n\n\tconst CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0';\n\n\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n}\n\nfunction isFbxFormatASCII( text ) {\n\n\tconst CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\tlet cursor = 0;\n\n\tfunction read( offset ) {\n\n\t\tconst result = text[ offset - 1 ];\n\t\ttext = text.slice( cursor + offset );\n\t\tcursor ++;\n\t\treturn result;\n\n\t}\n\n\tfor ( let i = 0; i < CORRECT.length; ++ i ) {\n\n\t\tconst num = read( 1 );\n\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction getFbxVersion( text ) {\n\n\tconst versionRegExp = /FBXVersion: (\\d+)/;\n\tconst match = text.match( versionRegExp );\n\n\tif ( match ) {\n\n\t\tconst version = parseInt( match[ 1 ] );\n\t\treturn version;\n\n\t}\n\n\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n}\n\n// Converts FBX ticks into real time seconds.\nfunction convertFBXTimeToSeconds( time ) {\n\n\treturn time / 46186158000;\n\n}\n\nconst dataArray = [];\n\n// extracts the data from the correct position in the FBX array based on indexing type\nfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\tlet index;\n\n\tswitch ( infoObject.mappingType ) {\n\n\t\tcase 'ByPolygonVertex' :\n\t\t\tindex = polygonVertexIndex;\n\t\t\tbreak;\n\t\tcase 'ByPolygon' :\n\t\t\tindex = polygonIndex;\n\t\t\tbreak;\n\t\tcase 'ByVertice' :\n\t\t\tindex = vertexIndex;\n\t\t\tbreak;\n\t\tcase 'AllSame' :\n\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t}\n\n\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\tconst from = index * infoObject.dataSize;\n\tconst to = from + infoObject.dataSize;\n\n\treturn slice( dataArray, infoObject.buffer, from, to );\n\n}\n\nconst tempEuler = new Euler();\nconst tempVec = new Vector3();\n\n// generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\nfunction generateTransform( transformData ) {\n\n\tconst lTranslationM = new Matrix4();\n\tconst lPreRotationM = new Matrix4();\n\tconst lRotationM = new Matrix4();\n\tconst lPostRotationM = new Matrix4();\n\n\tconst lScalingM = new Matrix4();\n\tconst lScalingPivotM = new Matrix4();\n\tconst lScalingOffsetM = new Matrix4();\n\tconst lRotationOffsetM = new Matrix4();\n\tconst lRotationPivotM = new Matrix4();\n\n\tconst lParentGX = new Matrix4();\n\tconst lParentLX = new Matrix4();\n\tconst lGlobalT = new Matrix4();\n\n\tconst inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t// For Maya models using \"Joint Orient\", Euler order only applies to rotation, not pre/post-rotations\n\tconst defaultEulerOrder = getEulerOrder( 0 );\n\n\tif ( transformData.preRotation ) {\n\n\t\tconst array = transformData.preRotation.map( MathUtils.degToRad );\n\t\tarray.push( defaultEulerOrder );\n\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.rotation ) {\n\n\t\tconst array = transformData.rotation.map( MathUtils.degToRad );\n\t\tarray.push( transformData.eulerOrder || defaultEulerOrder );\n\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t}\n\n\tif ( transformData.postRotation ) {\n\n\t\tconst array = transformData.postRotation.map( MathUtils.degToRad );\n\t\tarray.push( defaultEulerOrder );\n\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\tlPostRotationM.invert();\n\n\t}\n\n\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t// Pivots and offsets\n\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t// parent transform\n\tif ( transformData.parentMatrixWorld ) {\n\n\t\tlParentLX.copy( transformData.parentMatrix );\n\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t}\n\n\tconst lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );\n\t// Global Rotation\n\tconst lParentGRM = new Matrix4();\n\tlParentGRM.extractRotation( lParentGX );\n\n\t// Global Shear*Scaling\n\tconst lParentTM = new Matrix4();\n\tlParentTM.copyPosition( lParentGX );\n\n\tconst lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );\n\tconst lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );\n\tconst lLSM = lScalingM;\n\n\tconst lGlobalRS = new Matrix4();\n\n\tif ( inheritType === 0 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t} else if ( inheritType === 1 ) {\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t} else {\n\n\t\tconst lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );\n\t\tconst lParentLSM_inv = lParentLSM.clone().invert();\n\t\tconst lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );\n\n\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t}\n\n\tconst lRotationPivotM_inv = lRotationPivotM.clone().invert();\n\tconst lScalingPivotM_inv = lScalingPivotM.clone().invert();\n\t// Calculate the local transform matrix\n\tlet lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\tconst lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );\n\n\tconst lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );\n\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\tlTransform = lGlobalT.clone().multiply( lGlobalRS );\n\n\t// from global to local\n\tlTransform.premultiply( lParentGX.invert() );\n\n\treturn lTransform;\n\n}\n\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\nfunction getEulerOrder( order ) {\n\n\torder = order || 0;\n\n\tconst enums = [\n\t\t'ZYX', // -> XYZ extrinsic\n\t\t'YZX', // -> XZY extrinsic\n\t\t'XZY', // -> YZX extrinsic\n\t\t'ZXY', // -> YXZ extrinsic\n\t\t'YXZ', // -> ZXY extrinsic\n\t\t'XYZ', // -> ZYX extrinsic\n\t\t//'SphericXYZ', // not possible to support\n\t];\n\n\tif ( order === 6 ) {\n\n\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\treturn enums[ 0 ];\n\n\t}\n\n\treturn enums[ order ];\n\n}\n\n// Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\nfunction parseNumberArray( value ) {\n\n\tconst array = value.split( ',' ).map( function ( val ) {\n\n\t\treturn parseFloat( val );\n\n\t} );\n\n\treturn array;\n\n}\n\nfunction convertArrayBufferToString( buffer, from, to ) {\n\n\tif ( from === undefined ) from = 0;\n\tif ( to === undefined ) to = buffer.byteLength;\n\n\treturn new TextDecoder().decode( new Uint8Array( buffer, from, to ) );\n\n}\n\nfunction append( a, b ) {\n\n\tfor ( let i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n}\n\nfunction slice( a, b, from, to ) {\n\n\tfor ( let i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\ta[ j ] = b[ i ];\n\n\t}\n\n\treturn a;\n\n}\n\n\nexport { FBXLoader };\n"],
  "mappings": "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",
  "names": ["r", "j", "child", "material", "skeleton"]
}
